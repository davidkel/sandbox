---
# Logging section
logging:
 # Spec
 spec: debug
 # Format
 format: '%{color}%{time:2006-01-02 15:04:05.000 MST} [%{module}] %{shortfunc} -> %{level:.4s} %{id:03x}%{color:reset} %{message}'
fsc:
  # The FSC id provides a name for this node instance and is used when
  # naming docker resources.
  id: fsc.{{ hostvars[????].ansible_host }}
  # The networkId allows for logical separation of networks and is used when
  # naming docker resources.
  networkId: {{ fsc.networkid }}
  # This represents the endpoint to other FSC nodes in the same organization. TODO: Can't have 2 fsc nodes on the same machine would need more work
  address: {{ hostvars[????].ansible_host }}:20000
  # Whether the FSC node should programmatically determine its address
  # This case is useful for docker containers.
  # When set to true, will override FSC address.
  addressAutoDetect: false # true
  # GRPC Server listener address
  listenAddress: {{ hostvars[????].ansible_host }}:20000
  # Identity of this node, used to connect to other nodes
  identity:
    # X.509 certificate used as identity of this node
    cert:
      file: {{ fsc.cert }}
    # Private key matching the X.509 certificate
    key:
      file: {{ fsc.key }}
  # Admin X.509 certificates
  admin:
    certs:
    - {{ fsc.adminCert }}
  # TLS Settings
  # (We use here the same set of properties as Hyperledger Fabric)
  tls:
    # Require server-side TLS
    enabled:  true
    # Require client certificates / mutual TLS for inbound connections.
    # Note that clients that are not configured to use a certificate will
    # fail to connect to the node.
    clientAuthRequired: false
    # X.509 certificate used for TLS server
    cert:
      file: {{ fsc.tlsCert }}
    # Private key used for TLS server
    key:
      file: {{ fsc.tlsKey }}
    # X.509 certificate used for TLS when making client connections.
    # If not set, fsc.tls.cert.file will be used instead

  # Keepalive settings for node server and clients
  keepalive:
    # MinInterval is the minimum permitted time between client pings.
    # If clients send pings more frequently, the peer server will
    # disconnect them
    minInterval: 60s
    # Interval is the duration after which if the server does not see
    # any activity from the client it pings the client to see if it's alive
    interval: 300s
    # Timeout is the duration the server waits for a response
    # from the client after sending a ping before closing the connection
    timeout: 600s
  # P2P configuration
  p2p:
    # Listening address # TODO: Hardcoded port so have to have 1 fsc node per machine currently
    listenAddress:  /ip4/{{ hostvars[????].ansible_host }}/tcp/20001
    # If empty, this is a P2P boostrap node. Otherwise, it contains the name of the FCS node that is a bootstrap node
    bootstrapNode: {{ p2pBootstrapNode }}
  # The Key-Value Store is used to store various information related to the FSC node
  kvs:
    persistence:
      # Persistence type can be \'badger\' (on disk) or \'memory\'
      type: badger
      opts:
        path: {{ fsc.kvsPath }}
  # HTML Server configuration for REST calls
  web:
    enabled: true
    # HTTPS server listener address TODO: hardcoded port
    address: 0.0.0.0:20002
    tls:
      enabled:  true
      cert:
        file: {{ fsc.tlsCert }}
      key:
        file: {{ fsc.tlsKey }}

  metrics:
    # metrics provider is one of statsd, prometheus, or disabled
    provider: prometheus

  # The endpoint section tells how to reach other FSC node in the network.
  # For each node, the name, the domain, the identity of the node, and its addresses must be specified.

  endpoint:
    resolvers:
    #TODO: need to exclude self
    {% for fscnode in (fsc.nodes | default([])) %}
    - name: {{ fscnode.name }}
      domain: {{ fscnode.domain }}
      identity:
        id: {{ fscnode.name }}
        path: {{ fscnode.cert}}
      addresses:
      #TODO: if this is the bootstrap node, need to add entry in here
      aliases:
    {% endfor %}


fabric:
  enabled: true
  default:
    default: true
    BCCSP:
      Default: SW
      SW:
        Hash: SHA2
        Security: 256
        FileKeyStore:
          KeyStore:
    mspConfigPath: {{ fsc.fabric.msp }}
    localMspId: {{ fsc.fabric.mspid }}
    msps:
    tls:
      enabled:  true
      clientAuthRequired: false
      cert:
        file: {{ fsc.fabric.tlsCert }}
      key:
        file: {{ fsc.fabric.tlsKey }}
      rootCertFile: {{ fsc.fabric.allRootCerts }}
      keepalive:
       client:
         interval: 60s
         timeout: 600s
       server:
         interval: 60s
         timeout: 600s
         minInterval: 60s
    peers:
      # TODO: Support multiple peers, plus other properties should be configurable
      - address: {{ fsc.fabric.peer.endpoint }}
        connectionTimeout: 10s
        tlsEnabled: true
        tlsRootCertFile: {{fsc.fabric.peer.tlsRootCert }}
        serverNameOverride: {{ fsc.fabric.peer.serverNameOverride }}
    channels:
      #TODO: Support more than 1 channel
      - name: {{ fsc.fabric.channel }}
        default: true
        chaincodes:
          - name: {{ fsc.fabric.chaincodeid }}
            private: false
    vault:
      persistence:
        type: file
        opts:
          path: {{ fsc.fabric.vaultPath }}


#    endpoint:
#      resolvers:
#      - name: Org1_peer_0
#        domain: org1.example.com
#        identity:
#          id: Org1_peer_0
#          mspType: bccsp
#          mspID: Org1MSP
#          path: /home/dave/github-cloned/fabric-smart-client/samples/fabric/iou/testdata/fabric.default/crypto/peerOrganizations/org1.example.com/peers/Org1_peer_0.org1.example.com/msp/signcerts/Org1_peer_0.org1.example.com-cert.pem
#        addresses:
#           Listen: 127.0.0.1:20013
#        aliases:
#      - name: Org2_peer_0
#        domain: org2.example.com
#        identity:
#          id: Org2_peer_0
#          mspType: bccsp
#          mspID: Org2MSP
#          path: /home/dave/github-cloned/fabric-smart-client/samples/fabric/iou/testdata/fabric.default/crypto/peerOrganizations/org2.example.com/peers/Org2_peer_0.org2.example.com/msp/signcerts/Org2_peer_0.org2.example.com-cert.pem
#        addresses:
#           Listen: 127.0.0.1:20020
#        aliases:
#      - name: Org3_peer_0
#        domain: org3.example.com
#        identity:
#          id: Org3_peer_0
#          mspType: bccsp
#          mspID: Org3MSP
#          path: /home/dave/github-cloned/fabric-smart-client/samples/fabric/iou/testdata/fabric.default/crypto/peerOrganizations/org3.example.com/peers/Org3_peer_0.org3.example.com/msp/signcerts/Org3_peer_0.org3.example.com-cert.pem
#        addresses:
#           Listen: 127.0.0.1:20027
#        aliases:
#      - name: approver
#        domain: org1.example.com
#        identity:
#          id: approver
#          mspType: bccsp
#          mspID: Org1MSP
#          path: /home/dave/github-cloned/fabric-smart-client/samples/fabric/iou/testdata/fabric.default/crypto/peerOrganizations/org1.example.com/peers/approver.org1.example.com/msp/signcerts/approver.org1.example.com-cert.pem
#        addresses:
#        aliases:
#      - name: borrower
#        domain: org2.example.com
#        identity:
#          id: borrower
#          mspType: bccsp
#          mspID: Org2MSP
#          path: /home/dave/github-cloned/fabric-smart-client/samples/fabric/iou/testdata/fabric.default/crypto/peerOrganizations/org2.example.com/peers/borrower.org2.example.com/msp/signcerts/borrower.org2.example.com-cert.pem
#        addresses:
#        aliases:
#      - name: lender
#        domain: org3.example.com
#        identity:
#          id: lender
#          mspType: bccsp
#          mspID: Org3MSP
#          path: /home/dave/github-cloned/fabric-smart-client/samples/fabric/iou/testdata/fabric.default/crypto/peerOrganizations/org3.example.com/peers/lender.org3.example.com/msp/signcerts/lender.org3.example.com-cert.pem
#        addresses:
#        aliases:

